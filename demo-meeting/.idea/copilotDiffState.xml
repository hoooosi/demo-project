<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/!docs/权限校验系统使用说明.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/!docs/权限校验系统使用说明.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# 权限校验系统使用说明&#10;&#10;## 概述&#10;本项目使用 AOP（面向切面编程）+ Filter 实现了基于 Token 的登录权限校验系统。&#10;&#10;## 架构设计&#10;&#10;### 请求处理流程&#10;```&#10;1. 客户端请求（携带 token）&#10;   ↓&#10;2. ThreadLocalCleanupFilter 拦截&#10;   - 从请求头获取 token&#10;   - 从 Redis 验证 token 并获取 userId&#10;   - 构建 UserContext 并存入 ThreadLocal&#10;   ↓&#10;3. Controller 方法&#10;   - @CheckLogin 注解的方法会被 LoginCheckAspect 拦截验证&#10;   - 通过 TokenUtils 获取用户信息&#10;   ↓&#10;4. 请求结束&#10;   - ThreadLocalCleanupFilter 自动清理 ThreadLocal&#10;```&#10;&#10;## 核心组件&#10;&#10;### 1. UserContext (Record)&#10;- **位置**: `io.github.hoooosi.meeting.context.UserContext`&#10;- **作用**: 保存当前请求的用户上下文信息&#10;- **字段**: &#10;  - `token`: 用户令牌&#10;  - `userId`: 用户ID&#10;  - 后续可扩展更多字段（如 username, roles 等）&#10;&#10;```java&#10;public record UserContext(String token, Long userId) {&#10;    // 创建空上下文&#10;    public static UserContext empty() {&#10;        return new UserContext(null, null);&#10;    }&#10;    &#10;    // 检查是否已登录&#10;    public boolean isLogin() {&#10;        return userId != null;&#10;    }&#10;}&#10;```&#10;&#10;### 2. ThreadLocalCleanupFilter&#10;- **位置**: `io.github.hoooosi.meeting.filter.ThreadLocalCleanupFilter`&#10;- **作用**: 在每个请求开始时统一解析 token 并设置用户上下文&#10;- **优势**:&#10;  - 统一的 token 解析逻辑&#10;  - 避免重复的 Redis 查询&#10;  - 自动清理 ThreadLocal，防止内存泄漏&#10;&#10;### 3. @CheckLogin 注解&#10;- **位置**: `io.github.hoooosi.meeting.annotation.CheckLogin`&#10;- **作用**: 标记需要登录才能访问的方法&#10;&#10;### 4. LoginCheckAspect 切面&#10;- **位置**: `io.github.hoooosi.meeting.aspect.LoginCheckAspect`&#10;- **作用**: 拦截 `@CheckLogin` 注解的方法，验证用户是否已登录&#10;- **简化**: 不再需要解析 token，直接检查 ThreadLocal 中的 UserContext&#10;&#10;### 5. TokenUtils 工具类&#10;- **位置**: `io.github.hoooosi.meeting.utils.TokenUtils`&#10;- **作用**: 提供便捷的用户信息获取和权限校验方法&#10;- **升级**: 现在从 ThreadLocal 获取 UserContext，不再需要访问 Redis&#10;&#10;## TokenUtils 主要方法&#10;&#10;### 获取用户上下文&#10;```java&#10;// 获取完整的用户上下文&#10;UserContext context = TokenUtils.getUserContext();&#10;&#10;// 获取 token&#10;String token = tokenUtils.getToken();&#10;&#10;// 获取用户ID（可能为null）&#10;Long userId = tokenUtils.getUserId();&#10;&#10;// 获取用户ID（未登录抛异常）&#10;Long userId = tokenUtils.getRequiredUserId();&#10;```&#10;&#10;### 登录状态检查&#10;```java&#10;// 检查是否已登录&#10;if (tokenUtils.isLogin()) {&#10;    // 已登录逻辑&#10;}&#10;&#10;// 检查是否未登录&#10;if (tokenUtils.isNotLogin()) {&#10;    // 未登录逻辑&#10;}&#10;```&#10;&#10;### 强制登录校验&#10;```java&#10;// 要求必须已登录&#10;tokenUtils.requireLogin();&#10;&#10;// 要求必须未登录（用于注册/登录接口）&#10;tokenUtils.requireNotLogin();&#10;```&#10;&#10;### 用户身份验证&#10;```java&#10;// 检查是否为当前用户&#10;if (tokenUtils.isCurrentUser(targetUserId)) {&#10;    // 是当前用户&#10;}&#10;&#10;// 要求必须是指定用户&#10;tokenUtils.requireCurrentUser(targetUserId);&#10;```&#10;&#10;## 使用示例&#10;&#10;### 示例1: 需要登录的接口&#10;```java&#10;@CheckLogin&#10;@GetMapping(&quot;/info&quot;)&#10;public Resp&lt;User&gt; getUserInfo() {&#10;    // Filter 已经解析并验证了 token&#10;    // 直接从 TokenUtils 获取用户ID&#10;    Long userId = tokenUtils.getUserId();&#10;    User user = userService.getById(userId);&#10;    return Resp.success(user);&#10;}&#10;```&#10;&#10;### 示例2: 获取完整的用户上下文&#10;```java&#10;@CheckLogin&#10;@GetMapping(&quot;/profile&quot;)&#10;public Resp&lt;Map&lt;String, Object&gt;&gt; getProfile() {&#10;    UserContext context = TokenUtils.getUserContext();&#10;    &#10;    Map&lt;String, Object&gt; profile = new HashMap&lt;&gt;();&#10;    profile.put(&quot;userId&quot;, context.userId());&#10;    profile.put(&quot;token&quot;, context.token());&#10;    // 可以添加更多信息&#10;    &#10;    return Resp.success(profile);&#10;}&#10;```&#10;&#10;### 示例3: 验证资源所有权&#10;```java&#10;@CheckLogin&#10;@DeleteMapping(&quot;/meeting/{id}&quot;)&#10;public Resp&lt;Void&gt; deleteMeeting(@PathVariable Long id) {&#10;    Meeting meeting = meetingService.getById(id);&#10;    &#10;    // 验证是否为创建者&#10;    tokenUtils.requireCurrentUser(meeting.getCreator());&#10;    &#10;    meetingService.removeById(id);&#10;    return Resp.success();&#10;}&#10;```&#10;&#10;### 示例4: 在 Service 层使用&#10;```java&#10;@Service&#10;public class MeetingServiceImpl extends ServiceImpl&lt;MeetingMapper, Meeting&gt; implements MeetingService {&#10;    &#10;    private final TokenUtils tokenUtils;&#10;    &#10;    public void createMeeting(String meetingName) {&#10;        // Service 层也可以获取当前用户信息&#10;        Long userId = tokenUtils.getUserId();&#10;        &#10;        Meeting meeting = new Meeting();&#10;        meeting.setMeetingName(meetingName);&#10;        meeting.setCreator(userId);&#10;        this.save(meeting);&#10;    }&#10;}&#10;```&#10;&#10;### 示例5: 可选登录的接口&#10;```java&#10;@GetMapping(&quot;/meetings&quot;)&#10;public Resp&lt;List&lt;Meeting&gt;&gt; listMeetings() {&#10;    // 不加 @CheckLogin 注解&#10;    // 但可以检查登录状态，提供不同的数据&#10;    &#10;    if (tokenUtils.isLogin()) {&#10;        Long userId = tokenUtils.getUserId();&#10;        // 返回用户相关的会议&#10;        return Resp.success(meetingService.getByUser(userId));&#10;    } else {&#10;        // 返回公开的会议&#10;        return Resp.success(meetingService.getPublicMeetings());&#10;    }&#10;}&#10;```&#10;&#10;## 扩展 UserContext&#10;&#10;如果需要保存更多用户信息，只需修改 UserContext record：&#10;&#10;```java&#10;// 扩展示例&#10;public record UserContext(&#10;    String token, &#10;    Long userId,&#10;    String username,      // 新增：用户名&#10;    Set&lt;String&gt; roles     // 新增：用户角色&#10;) {&#10;    public static UserContext empty() {&#10;        return new UserContext(null, null, null, Set.of());&#10;    }&#10;    &#10;    public boolean isLogin() {&#10;        return userId != null;&#10;    }&#10;    &#10;    // 新增：检查是否有某个角色&#10;    public boolean hasRole(String role) {&#10;        return roles != null &amp;&amp; roles.contains(role);&#10;    }&#10;}&#10;```&#10;&#10;然后在 `ThreadLocalCleanupFilter` 中从 Redis 获取更多信息：&#10;&#10;```java&#10;private void parseAndSetUserContext(ServletRequest request) {&#10;    // ...获取 token...&#10;    &#10;    // 从 Redis 获取用户信息（可以是一个完整的用户对象）&#10;    Long userId = redisUtils.getUserIdByToken(token);&#10;    String username = redisUtils.getUsernameByToken(token);&#10;    Set&lt;String&gt; roles = redisUtils.getUserRolesByToken(token);&#10;    &#10;    UserContext userContext = new UserContext(token, userId, username, roles);&#10;    TokenUtils.setUserContext(userContext);&#10;}&#10;```&#10;&#10;## 性能优势&#10;&#10;1. **减少 Redis 查询**: 每个请求只查询一次 Redis（在 Filter 中），后续都从 ThreadLocal 获取&#10;2. **统一解析**: Token 解析逻辑集中在 Filter 中，避免分散在各个地方&#10;3. **自动管理**: Filter 自动清理 ThreadLocal，无需手动管理&#10;&#10;## 错误码说明&#10;&#10;| 错误码 | 说明 |&#10;|-------|------|&#10;| UNAUTHORIZED (40100) | 未授权：未登录或 token 无效 |&#10;| TOKEN_INVALID (40101) | Token 无效或已过期 |&#10;| ALREADY_LOGIN (40102) | 已登录（用于注册/登录接口校验） |&#10;| FORBIDDEN (40300) | 权限不足（无权访问资源） |&#10;&#10;## 请求头格式&#10;&#10;```&#10;GET /user/info HTTP/1.1&#10;Host: localhost:8080&#10;token: your-token-here&#10;```&#10;&#10;## 注意事项&#10;&#10;1. 需要在启动类添加 `@ServletComponentScan` 注解以启用 Filter&#10;2. Filter 在所有请求前执行，自动解析 token 并设置用户上下文&#10;3. `@CheckLogin` 注解用于强制要求登录&#10;4. 不加注解的接口也可以通过 `tokenUtils.isLogin()` 检查登录状态&#10;5. UserContext 是 record 类型，不可变且线程安全" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>